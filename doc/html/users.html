

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>User documentation &mdash; RecSQL v0.7.4 documentation</title>
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.7.4',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="RecSQL v0.7.4 documentation" href="index.html" />
    <link rel="next" title="Notes for developers" href="programmers.html" />
    <link rel="prev" title="INSTALL" href="INSTALL.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="programmers.html" title="Notes for developers"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="INSTALL.html" title="INSTALL"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">RecSQL v0.7.4 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-recsql">
<span id="user-documentation"></span><h1>User documentation<a class="headerlink" href="#module-recsql" title="Permalink to this headline">¶</a></h1>
<div class="section" id="recsql-package">
<h2>RecSQL package<a class="headerlink" href="#recsql-package" title="Permalink to this headline">¶</a></h2>
<p>RecSQL is a simple module that provides a numpy.record array frontend
to an underlying SQLite table.</p>
<p>The <a class="reference internal" href="#recsql.SQLarray" title="recsql.SQLarray"><tt class="xref py py-class docutils literal"><span class="pre">SQLarray</span></tt></a> object populates a SQL table from a numpy record array, a
iterable that supplies table records, or a string that contains an
especially simple reStructured text table. The SQL table is held in memory
and functions are provided to run SQL queries and commands on the
underlying database. Queries return record arrays if possible (although a
flag can explicitly change this).</p>
<p>Query results are cached to improve performance. This can be disabled
(which is recommened for large data sets).</p>
<p>The SQL table is named on initialization. Later one can refer to this table
by the name or the magic name <em>__self__</em> in SQL statements. Additional
tables can be added to the same database (by using the connection keyword
of the constructor)</p>
<p>The <a class="reference internal" href="programmers.html#module-recsql.rest_table" title="recsql.rest_table"><tt class="xref py py-mod docutils literal"><span class="pre">recsql.rest_table</span></tt></a> module uses the base functionality to
parse a restructured text table from a string (such as a doc string)
and returns a nicely structured table. This allows for use of
parameters that are documented in the doc strings.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference external" href="http://www.pytables.org">PyTables</a> is a high-performance interface to table
data. In most cases you will probably better off in the
long run using PyTables than recSQL.</p>
</div>
<div class="section" id="important-functions-and-classes">
<h3>Important functions and classes<a class="headerlink" href="#important-functions-and-classes" title="Permalink to this headline">¶</a></h3>
<p>A <a class="reference internal" href="#recsql.SQLarray" title="recsql.SQLarray"><tt class="xref py py-class docutils literal"><span class="pre">SQLarray</span></tt></a> can be constructed by either reading data from a
CSV file or reST table with the <a class="reference internal" href="#recsql.SQLarray_fromfile" title="recsql.SQLarray_fromfile"><tt class="xref py py-func docutils literal"><span class="pre">SQLarray_fromfile()</span></tt></a> function or
constructed directly from a <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.html#numpy.recarray" title="(in NumPy v2.0.dev8716)"><tt class="xref py py-class docutils literal"><span class="pre">numpy.recarray</span></tt></a> via the
<a class="reference internal" href="#recsql.SQLarray" title="recsql.SQLarray"><tt class="xref py py-class docutils literal"><span class="pre">SQLarray</span></tt></a> constructor.</p>
<dl class="function">
<dt id="recsql.SQLarray_fromfile">
<tt class="descclassname">recsql.</tt><tt class="descname">SQLarray_fromfile</tt><big>(</big><em>filename</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#recsql.SQLarray_fromfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a <a class="reference internal" href="#recsql.SQLarray" title="recsql.SQLarray"><tt class="xref py py-class docutils literal"><span class="pre">SQLarray</span></tt></a> from <em>filename</em>.</p>
<dl class="docutils">
<dt>Uses the filename suffix to detect the contents:</dt>
<dd><dl class="first last docutils">
<dt>rst, txt</dt>
<dd>restructure text (see <a class="reference internal" href="programmers.html#module-recsql.rest_table" title="recsql.rest_table"><tt class="xref py py-mod docutils literal"><span class="pre">recsql.rest_table</span></tt></a></dd>
<dt>csv</dt>
<dd>comma-separated (see <a class="reference internal" href="programmers.html#module-recsql.csv_table" title="recsql.csv_table"><tt class="xref py py-mod docutils literal"><span class="pre">recsql.csv_table</span></tt></a>)</dd>
</dl>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Arguments :</th><td class="field-body"><dl class="first last docutils">
<dt><em>filename</em></dt>
<dd><p class="first last">name of the file that contains the data with the appropriate
file extension</p>
</dd>
<dt><em>kwargs</em></dt>
<dd><ul class="first last simple">
<li>additional arguments for <a class="reference internal" href="#recsql.SQLarray" title="recsql.SQLarray"><tt class="xref py py-class docutils literal"><span class="pre">SQLarray</span></tt></a></li>
<li>additional arguments <a class="reference internal" href="programmers.html#recsql.csv_table.Table2array" title="recsql.csv_table.Table2array"><tt class="xref py py-class docutils literal"><span class="pre">recsql.csv_table.Table2array</span></tt></a> or
<a class="reference internal" href="programmers.html#recsql.rest_table.Table2array" title="recsql.rest_table.Table2array"><tt class="xref py py-class docutils literal"><span class="pre">recsql.rest_table.Table2array</span></tt></a> such as <em>mode</em> or
<em>autoncovert</em>.</li>
</ul>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="recsql.SQLarray">
<em class="property">class </em><tt class="descclassname">recsql.</tt><tt class="descname">SQLarray</tt><big>(</big><em>name=None</em>, <em>records=None</em>, <em>filename=None</em>, <em>columns=None</em>, <em>cachesize=5</em>, <em>connection=None</em>, <em>is_tmp=False</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#recsql.SQLarray" title="Permalink to this definition">¶</a></dt>
<dd><p>A SQL table that returns (mostly) rec arrays.</p>
<dl class="method">
<dt id="recsql.SQLarray.SQLarray">
<tt class="descname">SQLarray</tt><big>(</big><span class="optional">[</span><em>name</em><span class="optional">[</span>, <em>records</em><span class="optional">[</span>, <em>columns</em><span class="optional">[</span>, <em>cachesize=5</em>, <em>connection=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#recsql.SQLarray.SQLarray" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Arguments :</th><td class="field-body"><dl class="first docutils">
<dt>name        </dt>
<dd><p class="first last">table name (can be referred to as &#8216;__self__&#8217; in SQL queries)</p>
</dd>
<dt>records    </dt>
<dd><p class="first last">numpy record array that describes the layout and initializes the
table OR any iterable (and then columns must be set, too) OR a string
that contains a single, <em>simple reStructured text table</em> (and the table name is
set from the table name in the reST table.)
If <tt class="xref docutils literal"><span class="pre">None</span></tt> then simply associate with existing table name.</p>
</dd>
<dt>filename</dt>
<dd><p class="first last">Alternatively to <em>records</em>, read a reStructured table from <em>filename</em>.</p>
</dd>
<dt>columns</dt>
<dd><p class="first last">sequence of column names (only used if records does not have 
attribute dtype.names) [<tt class="xref docutils literal"><span class="pre">None</span></tt>]</p>
</dd>
<dt>cachesize   </dt>
<dd><p class="first last">number of (query, result) pairs that are cached [5]</p>
</dd>
<dt>connection  </dt>
<dd><p class="first last">If not <tt class="xref docutils literal"><span class="pre">None</span></tt>, reuse this connection; this adds a new table to the same 
database, which allows more complicated queries with cross-joins. The 
table&#8217;s connection is available as the attribute T.connection. [<tt class="xref docutils literal"><span class="pre">None</span></tt>]</p>
</dd>
<dt>is_tmp</dt>
<dd><p class="first last"><tt class="xref docutils literal"><span class="pre">True</span></tt>: create a tmp table; <tt class="xref docutils literal"><span class="pre">False</span></tt>: regular table in db [<tt class="xref docutils literal"><span class="pre">False</span></tt>]</p>
</dd>
</dl>
</td>
</tr>
<tr class="field"><th class="field-name">Bugs :</th><td class="field-body"><ul class="first last">
<li><p class="first"><tt class="xref py py-exc docutils literal"><span class="pre">InterfaceError</span></tt>: <em>Error binding parameter 0 - probably unsupported type</em></p>
<p>In this case the recarray contained types such as <tt class="docutils literal"><span class="pre">numpy.int64</span></tt> that are not
understood by sqlite. Either convert the data manually (by setting the numpy 
dtypes yourself on the recarray, or better: feed a simple list of tuples (&#8220;records&#8221;)
to this class in <em>records</em>. Make sure that these tuples only contain standard python types.
Together with <em>records</em> you will also have to supply the names of the data columns
in the keyword argument <em>columns</em>.</p>
<p>If you are reading from a file then it might be simpler to
use <a class="reference internal" href="programmers.html#recsql.sqlarray.SQLarray_fromfile" title="recsql.sqlarray.SQLarray_fromfile"><tt class="xref py py-func docutils literal"><span class="pre">recsql.sqlarray.SQLarray_fromfile()</span></tt></a>.</p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="recsql.SQLarray.SELECT">
<tt class="descname">SELECT</tt><big>(</big><em>fields</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#recsql.SQLarray.SELECT" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute a simple SQL <tt class="docutils literal"><span class="pre">SELECT</span></tt> statement and returns values as new numpy rec array.</p>
<p>The arguments <em>fields</em> and the additional optional arguments
are simply concatenated with additional SQL statements
according to the template:</p>
<div class="highlight-python"><pre>SELECT &lt;fields&gt; FROM __self__ [args]</pre>
</div>
<p>The simplest fields argument is <tt class="docutils literal"><span class="pre">&quot;*&quot;</span></tt>.</p>
<dl class="docutils">
<dt>Example:</dt>
<dd><p class="first">Create a recarray in which students with average grade less than
3 are listed:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">result</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">SELECT</span><span class="p">(</span><span class="s">&quot;surname, subject, year, avg(grade) AS avg_grade&quot;</span><span class="p">,</span>
               <span class="s">&quot;WHERE avg_grade &lt; 3&quot;</span><span class="p">,</span> <span class="s">&quot;GROUP BY surname,subject&quot;</span><span class="p">,</span>
               <span class="s">&quot;ORDER BY avg_grade,surname&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>The resulting SQL would be:</p>
<div class="highlight-python"><pre>SELECT surname, subject, year, avg(grade) AS avg_grade FROM __self__
     WHERE avg_grade &lt; 3
     GROUP BY surname,subject
     ORDER BY avg_grade,surname</pre>
</div>
<p>Note how one can use aggregate functions such avg().</p>
<p>The string <em>&#8216;__self__&#8217;</em> is automatically replaced with the table
name (<tt class="docutils literal"><span class="pre">T.name</span></tt>); this can be used for cartesian products such as</p>
<div class="last highlight-python"><pre>LEFT JOIN __self__ WHERE ...</pre>
</div>
</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">See the documentation for <a class="reference internal" href="#recsql.SQLarray.sql" title="recsql.SQLarray.sql"><tt class="xref py py-meth docutils literal"><span class="pre">sql()</span></tt></a> for more details on
the available keyword arguments and the use of <tt class="docutils literal"><span class="pre">?</span></tt> parameter
interpolation.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="recsql.SQLarray.limits">
<tt class="descname">limits</tt><big>(</big><em>variable</em><big>)</big><a class="headerlink" href="#recsql.SQLarray.limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Return minimum and maximum of variable across all rows of data.</p>
</dd></dl>

<dl class="method">
<dt id="recsql.SQLarray.merge">
<tt class="descname">merge</tt><big>(</big><em>recarray</em>, <em>columns=None</em><big>)</big><a class="headerlink" href="#recsql.SQLarray.merge" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge another recarray with the same columns into this table.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Arguments :</th><td class="field-body"><dl class="first docutils">
<dt>recarray    </dt>
<dd><p class="first last">numpy record array that describes the layout and initializes the
table</p>
</dd>
</dl>
</td>
</tr>
<tr class="field"><th class="field-name">Returns :</th><td class="field-body"><p class="first">n           number of inserted rows</p>
</td>
</tr>
<tr class="field"><th class="field-name">Raises :</th><td class="field-body"><p class="first last">Raises an exception if duplicate and incompatible data exist
in the main table and the new one.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="recsql.SQLarray.merge_table">
<tt class="descname">merge_table</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#recsql.SQLarray.merge_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge an existing table in the database with the __self__ table.</p>
<p>Executes as <tt class="docutils literal"><span class="pre">'INSERT</span> <span class="pre">INTO</span> <span class="pre">__self__</span> <span class="pre">SELECT</span> <span class="pre">*</span> <span class="pre">FROM</span> <span class="pre">&lt;name&gt;'</span></tt>.
However, this method is probably used less often than the simpler <a class="reference internal" href="#recsql.SQLarray.merge" title="recsql.SQLarray.merge"><tt class="xref py py-meth docutils literal"><span class="pre">merge()</span></tt></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Arguments :</th><td class="field-body">name         name of the table in the database (must be compatible with __self__)</td>
</tr>
<tr class="field"><th class="field-name">Returns :</th><td class="field-body">n            number of inserted rows</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="recsql.SQLarray.recarray">
<tt class="descname">recarray</tt><a class="headerlink" href="#recsql.SQLarray.recarray" title="Permalink to this definition">¶</a></dt>
<dd><p>Return underlying SQL table as a read-only record array.</p>
</dd></dl>

<dl class="method">
<dt id="recsql.SQLarray.selection">
<tt class="descname">selection</tt><big>(</big><em>SQL</em>, <em>parameters=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#recsql.SQLarray.selection" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new SQLarray from a SELECT selection.</p>
<p>This is a very useful method because it allows one to build complicated
selections and essentially new tables from existing data.</p>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">s</span> <span class="o">=</span> <span class="n">selection</span><span class="p">(</span><span class="s">&#39;a &gt; 3&#39;</span><span class="p">)</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">selection</span><span class="p">(</span><span class="s">&#39;a &gt; ?&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,))</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">selection</span><span class="p">(</span><span class="s">&#39;SELECT * FROM __self__ WHERE a &gt; ? AND b &lt; ?&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="recsql.SQLarray.sql">
<tt class="descname">sql</tt><big>(</big><em>SQL</em>, <em>parameters=None</em>, <em>asrecarray=True</em>, <em>cache=True</em><big>)</big><a class="headerlink" href="#recsql.SQLarray.sql" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute sql statement.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Arguments :</th><td class="field-body"><dl class="first last docutils">
<dt>SQL <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">Full SQL command; can contain the <tt class="docutils literal"><span class="pre">?</span></tt> place holder so that values
supplied with the <tt class="docutils literal"><span class="pre">parameters</span></tt> keyword can be interpolated using
the <tt class="docutils literal"><span class="pre">pysqlite</span></tt> interface.</p>
</dd>
<dt>parameters <span class="classifier-delimiter">:</span> <span class="classifier">tuple</span></dt>
<dd><p class="first last">Parameters for <tt class="docutils literal"><span class="pre">?</span></tt> interpolation.</p>
</dd>
<dt>asrecarray <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><p class="first last"><tt class="xref docutils literal"><span class="pre">True</span></tt>: return a <tt class="docutils literal"><span class="pre">numpy.recarray</span></tt> if possible;
<tt class="xref docutils literal"><span class="pre">False</span></tt>: return records as a list of tuples. [<tt class="xref docutils literal"><span class="pre">True</span></tt>]</p>
</dd>
<dt>cache <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><p class="first last">Should the results be cached? Set to <tt class="xref docutils literal"><span class="pre">False</span></tt> for large queries to
avoid memory issues. Queries with <tt class="docutils literal"><span class="pre">?</span></tt> place holders are never cached.
[<tt class="xref docutils literal"><span class="pre">True</span></tt>]</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">There are <strong>no sanity checks</strong> applied to the SQL.</p>
</div>
<p>If  possible, the  returned list  of tuples  is turned  into a
numpy record  array, otherwise the original list  of tuples is
returned.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Potential BUG: if there are memory issues then it can
happen that we just silently fall back to a tuple even
though calling code expects a recarray; because we
swallowed ANY exception the caller will never know</p>
</div>
<p>The last cachesize queries are cached (for cache=True) and are
returned directly unless the table has been modified.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">&#8216;__self__&#8217; is substituted with the table name. See the doc
string of the <a class="reference internal" href="#recsql.SQLarray.SELECT" title="recsql.SQLarray.SELECT"><tt class="xref py py-meth docutils literal"><span class="pre">SELECT()</span></tt></a> method for more details.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="recsql.SQLarray.sql_index">
<tt class="descname">sql_index</tt><big>(</big><em>index_name</em>, <em>column_names</em>, <em>unique=True</em><big>)</big><a class="headerlink" href="#recsql.SQLarray.sql_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a named index on given columns to improve performance.</p>
</dd></dl>

<dl class="method">
<dt id="recsql.SQLarray.sql_select">
<tt class="descname">sql_select</tt><big>(</big><em>fields</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#recsql.SQLarray.sql_select" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute a simple SQL <tt class="docutils literal"><span class="pre">SELECT</span></tt> statement and returns values as new numpy rec array.</p>
<p>The arguments <em>fields</em> and the additional optional arguments
are simply concatenated with additional SQL statements
according to the template:</p>
<div class="highlight-python"><pre>SELECT &lt;fields&gt; FROM __self__ [args]</pre>
</div>
<p>The simplest fields argument is <tt class="docutils literal"><span class="pre">&quot;*&quot;</span></tt>.</p>
<dl class="docutils">
<dt>Example:</dt>
<dd><p class="first">Create a recarray in which students with average grade less than
3 are listed:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">result</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">SELECT</span><span class="p">(</span><span class="s">&quot;surname, subject, year, avg(grade) AS avg_grade&quot;</span><span class="p">,</span>
               <span class="s">&quot;WHERE avg_grade &lt; 3&quot;</span><span class="p">,</span> <span class="s">&quot;GROUP BY surname,subject&quot;</span><span class="p">,</span>
               <span class="s">&quot;ORDER BY avg_grade,surname&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>The resulting SQL would be:</p>
<div class="highlight-python"><pre>SELECT surname, subject, year, avg(grade) AS avg_grade FROM __self__
     WHERE avg_grade &lt; 3
     GROUP BY surname,subject
     ORDER BY avg_grade,surname</pre>
</div>
<p>Note how one can use aggregate functions such avg().</p>
<p>The string <em>&#8216;__self__&#8217;</em> is automatically replaced with the table
name (<tt class="docutils literal"><span class="pre">T.name</span></tt>); this can be used for cartesian products such as</p>
<div class="last highlight-python"><pre>LEFT JOIN __self__ WHERE ...</pre>
</div>
</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">See the documentation for <a class="reference internal" href="#recsql.SQLarray.sql" title="recsql.SQLarray.sql"><tt class="xref py py-meth docutils literal"><span class="pre">sql()</span></tt></a> for more details on
the available keyword arguments and the use of <tt class="docutils literal"><span class="pre">?</span></tt> parameter
interpolation.</p>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="example">
<h3>Example<a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">recsql</span> <span class="kn">import</span> <span class="n">SQLarray</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">fromrecords</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">25</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">names</span><span class="o">=</span><span class="s">&#39;a,b,c,d&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Q</span> <span class="o">=</span> <span class="n">SQLarray</span><span class="p">(</span><span class="s">&#39;my_name&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="nb">repr</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">recarray</span><span class="p">)</span>
<span class="go">rec.array([(0, 1, 2, 3), (4, 5, 6, 7), (8, 9, 10, 11), (12, 13, 14, 15),</span>
<span class="go">       (16, 17, 18, 19), (20, 21, 22, 23), (24, 25, 26, 27),</span>
<span class="go">       (28, 29, 30, 31), (32, 33, 34, 35), (36, 37, 38, 39),</span>
<span class="go">       (40, 41, 42, 43), (44, 45, 46, 47), (48, 49, 50, 51),</span>
<span class="go">       (52, 53, 54, 55), (56, 57, 58, 59), (60, 61, 62, 63),</span>
<span class="go">       (64, 65, 66, 67), (68, 69, 70, 71), (72, 73, 74, 75),</span>
<span class="go">       (76, 77, 78, 79), (80, 81, 82, 83), (84, 85, 86, 87),</span>
<span class="go">       (88, 89, 90, 91), (92, 93, 94, 95), (96, 97, 98, 99)],</span>
<span class="go">      dtype=[(&#39;a&#39;, &#39;&lt;i4&#39;), (&#39;b&#39;, &#39;&lt;i4&#39;), (&#39;c&#39;, &#39;&lt;i4&#39;), (&#39;d&#39;, &#39;&lt;i4&#39;)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Q</span><span class="o">.</span><span class="n">SELECT</span><span class="p">(</span><span class="s">&#39;*&#39;</span><span class="p">,</span> <span class="s">&#39;WHERE a &lt; 10 AND b &gt; 5&#39;</span><span class="p">)</span>
<span class="go">rec.array([(8, 9, 10, 11)],</span>
<span class="go">    dtype=[(&#39;a&#39;, &#39;&lt;i4&#39;), (&#39;b&#39;, &#39;&lt;i4&#39;), (&#39;c&#39;, &#39;&lt;i4&#39;), (&#39;d&#39;, &#39;&lt;i4&#39;)])</span>
<span class="go"># creating new SQLarrays:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">selection</span><span class="p">(</span><span class="s">&#39;a &lt; 20 AND b &gt; 5&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">R</span>
<span class="go">&lt;recsql.sqlarray.SQLarray object at 0x...&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="additional-sql-functions">
<h3>Additional SQL functions<a class="headerlink" href="#additional-sql-functions" title="Permalink to this headline">¶</a></h3>
<p>Note that the SQL database that is used as the backend for
<a class="reference internal" href="#recsql.SQLarray" title="recsql.SQLarray"><tt class="xref py py-class docutils literal"><span class="pre">SQLarray</span></tt></a> has a few additional functions defined in addition
to the <a class="reference external" href="http://www.sqlite.org/lang.html">standard SQL available in sqlite</a>. These can be used in
<tt class="docutils literal"><span class="pre">SELECT</span></tt> statements and often avoid post-processing of record arrays
in python. It is relatively straightforward to add new functions (see
the source code and in particular the
<tt class="xref py py-meth docutils literal"><span class="pre">recsql.sqlarray.SQLarray._init_sql_functions()</span></tt> method; the
functions themselves are defined in the module <a class="reference internal" href="programmers.html#module-recsql.sqlfunctions" title="recsql.sqlfunctions"><tt class="xref py py-mod docutils literal"><span class="pre">recsql.sqlfunctions</span></tt></a>).</p>
<div class="section" id="simple-sql-functions">
<h4>Simple SQL functions<a class="headerlink" href="#simple-sql-functions" title="Permalink to this headline">¶</a></h4>
<p>Simple functions transform a single input value into a single output value:</p>
<table border="1" class="docutils">
<colgroup>
<col width="32%" />
<col width="68%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Expression</th>
<th class="head">SQL equivalent</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>y = f(x)</td>
<td>SELECT f(x) AS y</td>
</tr>
</tbody>
</table>
<p>Two additional simple functions have been defined:</p>
<table border="1" class="docutils">
<colgroup>
<col width="31%" />
<col width="69%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Simple SQL f()</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>sqrt(x)</td>
<td>square root math.sqrt(x)</td>
</tr>
<tr><td>pow(x,y)</td>
<td>power x**y</td>
</tr>
<tr><td>fformat(format,x)</td>
<td>string formatting of a single value format % x</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="aggregate-sql-functions">
<h4>Aggregate SQL functions<a class="headerlink" href="#aggregate-sql-functions" title="Permalink to this headline">¶</a></h4>
<p>Aggregate functions combine data from a query; they are typically used with
a &#8216;GROUP BY col&#8217; clause. They can be thought of as numpy ufuncs:</p>
<table border="1" class="docutils">
<colgroup>
<col width="32%" />
<col width="68%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Expression</th>
<th class="head">SQL equivalent</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>y = f(x1,x2,...xN)</td>
<td>SELECT f(x) AS y ... GROUP BY x</td>
</tr>
</tbody>
</table>
<p>For completeness, the tablke also lists sqlite built-in aggregate
functions:</p>
<table border="1" class="docutils">
<colgroup>
<col width="32%" />
<col width="68%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Simple aggregate f()</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>avg(x)</td>
<td>mean [sqlite builtin]</td>
</tr>
<tr><td>std(x)</td>
<td>standard deviation (using N-1 variance)</td>
</tr>
<tr><td>median(x)</td>
<td>median of the data (see <tt class="docutils literal"><span class="pre">numpy.median</span></tt>)</td>
</tr>
<tr><td>min(x)</td>
<td>minimum [sqlite builtin]</td>
</tr>
<tr><td>max(x)</td>
<td>maximum [sqlite builtin]</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="pyaggregate-sql-functions">
<h4>PyAggregate SQL functions<a class="headerlink" href="#pyaggregate-sql-functions" title="Permalink to this headline">¶</a></h4>
<p>PyAggregate functions act on a list of data points in the same way as
ordinary aggregate functions but they return python objects such as numpy
arrays, or tuples of numpy arrays (eg bin edges and histogram). In order to
make this work, specific types have to be declared when returning the
results:</p>
<p>For instance, the histogram() function returns a python Object, the tuple
(histogram, edges):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">a</span><span class="o">.</span><span class="n">sql</span><span class="p">(</span><span class="s">&#39;SELECT histogram(x) AS &quot;x [Object]&quot; FROM __self__&#39;</span><span class="p">,</span> <span class="n">asrecarray</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
<p>The return type (&#8216;Object&#8217;) needs to be declared with the <tt class="docutils literal"><span class="pre">'AS</span> <span class="pre">&quot;x</span> <span class="pre">[Object]&quot;'</span></tt>
syntax (note the quotes). (See more details in the <a class="reference external" href="http://docs.python.org/library/sqlite3.html">sqlite documentation</a>
under <a class="reference external" href="http://docs.python.org/library/sqlite3.html#using-adapters-to-store-additional-python-types-in-sqlite-databases">adapters and converters</a>.) The following table lists all <em>PyAggregate</em>
functions that have been defined:</p>
<table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="15%" />
<col width="68%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">PyAggregate</th>
<th class="head">type</th>
<th class="head">signature; description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>array</td>
<td>NumpyArray</td>
<td>array(x);
a standard numpy array</td>
</tr>
<tr><td>histogram</td>
<td>Object</td>
<td>histogram(x,nbins,xmin,xmax);
histogram x in nbins evenly spaced bins between xmin and xmax</td>
</tr>
<tr><td>distribution</td>
<td>Object</td>
<td>distribution(x,nbins,xmin,xmax);
normalized histogram whose integral gives 1</td>
</tr>
<tr><td>meanhistogram</td>
<td>Object</td>
<td>meanhistogram(x,y,nbins,xmin,xmax);
histogram data points y along x and average all y in each bin</td>
</tr>
<tr><td>stdhistogram</td>
<td>Object</td>
<td>stdhistogram(x,y,nbins,xmin,xmax);
give the standard deviation (from N-1 variance)
std(y) = sqrt(Var(y)) with Var(y) = &lt;(y-&lt;y&gt;)^2&gt;</td>
</tr>
<tr><td>medianhistogram</td>
<td>Object</td>
<td>medianhistogram((x,y,nbins,xmin,xmax);
median(y)</td>
</tr>
<tr><td>minhistogram</td>
<td>Object</td>
<td>minhistogram((x,y,nbins,xmin,xmax);
min(y)</td>
</tr>
<tr><td>maxhistogram</td>
<td>Object</td>
<td>maxhistogram((x,y,nbins,xmin,xmax);
max(y)</td>
</tr>
<tr><td>zscorehistogram</td>
<td>Object</td>
<td>zscorehistogram((x,y,nbins,xmin,xmax);
&lt;abs(y-&lt;y&gt;)&gt;/std(y)</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="examples-of-using-types-in-tables">
<h3>Examples of using types in tables<a class="headerlink" href="#examples-of-using-types-in-tables" title="Permalink to this headline">¶</a></h3>
<p>The following show how to use the special types.</p>
<p>Declare types as &#8216;NumpyArray&#8217;:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">a</span><span class="o">.</span><span class="n">sql</span><span class="p">(</span><span class="s">&quot;CREATE TABLE __self__(a NumpyArray)&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Then you can simply insert python objects (type(my_array) == numpy.ndarray):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">a</span><span class="o">.</span><span class="n">sql</span><span class="p">(</span><span class="s">&quot;INSERT INTO __self__(a) values (?)&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">my_array</span><span class="p">,))</span>
</pre></div>
</div>
<p>When returning results of declared columns one does not have to do anything</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">(</span><span class="n">my_array</span><span class="p">,)</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">sql</span><span class="p">(</span><span class="s">&quot;SELECT a FROM __self__&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>although one can also do</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">(</span><span class="n">my_array</span><span class="p">,)</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">sql</span><span class="p">(</span><span class="s">&#39;SELECT a AS &quot;a [NumpyArray]&quot; FROM __self__&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>but when using a PyAggregate the type <em>must</em> be declared:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">a</span><span class="o">.</span><span class="n">sql</span><span class="p">(</span><span class="s">&#39;SELECT histogram(x,10,0.0,1.5) as &quot;hist [Object]&quot; FROM __self__&#39;</span><span class="p">)</span>
</pre></div>
</div>
<dl class="class">
<dt>
<em class="property">class </em><tt class="descclassname">recsql.</tt><tt class="descname">SQLarray</tt><big>(</big><em>name=None</em>, <em>records=None</em>, <em>filename=None</em>, <em>columns=None</em>, <em>cachesize=5</em>, <em>connection=None</em>, <em>is_tmp=False</em>, <em>**kwargs</em><big>)</big></dt>
<dd><p>A SQL table that returns (mostly) rec arrays.</p>
<dl class="method">
<dt>
<tt class="descname">SQLarray</tt><big>(</big><span class="optional">[</span><em>name</em><span class="optional">[</span>, <em>records</em><span class="optional">[</span>, <em>columns</em><span class="optional">[</span>, <em>cachesize=5</em>, <em>connection=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big></dt>
<dd></dd></dl>

<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Arguments :</th><td class="field-body"><dl class="first docutils">
<dt>name        </dt>
<dd><p class="first last">table name (can be referred to as &#8216;__self__&#8217; in SQL queries)</p>
</dd>
<dt>records    </dt>
<dd><p class="first last">numpy record array that describes the layout and initializes the
table OR any iterable (and then columns must be set, too) OR a string
that contains a single, <em>simple reStructured text table</em> (and the table name is
set from the table name in the reST table.)
If <tt class="xref docutils literal"><span class="pre">None</span></tt> then simply associate with existing table name.</p>
</dd>
<dt>filename</dt>
<dd><p class="first last">Alternatively to <em>records</em>, read a reStructured table from <em>filename</em>.</p>
</dd>
<dt>columns</dt>
<dd><p class="first last">sequence of column names (only used if records does not have 
attribute dtype.names) [<tt class="xref docutils literal"><span class="pre">None</span></tt>]</p>
</dd>
<dt>cachesize   </dt>
<dd><p class="first last">number of (query, result) pairs that are cached [5]</p>
</dd>
<dt>connection  </dt>
<dd><p class="first last">If not <tt class="xref docutils literal"><span class="pre">None</span></tt>, reuse this connection; this adds a new table to the same 
database, which allows more complicated queries with cross-joins. The 
table&#8217;s connection is available as the attribute T.connection. [<tt class="xref docutils literal"><span class="pre">None</span></tt>]</p>
</dd>
<dt>is_tmp</dt>
<dd><p class="first last"><tt class="xref docutils literal"><span class="pre">True</span></tt>: create a tmp table; <tt class="xref docutils literal"><span class="pre">False</span></tt>: regular table in db [<tt class="xref docutils literal"><span class="pre">False</span></tt>]</p>
</dd>
</dl>
</td>
</tr>
<tr class="field"><th class="field-name">Bugs :</th><td class="field-body"><ul class="first last">
<li><p class="first"><tt class="xref py py-exc docutils literal"><span class="pre">InterfaceError</span></tt>: <em>Error binding parameter 0 - probably unsupported type</em></p>
<p>In this case the recarray contained types such as <tt class="docutils literal"><span class="pre">numpy.int64</span></tt> that are not
understood by sqlite. Either convert the data manually (by setting the numpy 
dtypes yourself on the recarray, or better: feed a simple list of tuples (&#8220;records&#8221;)
to this class in <em>records</em>. Make sure that these tuples only contain standard python types.
Together with <em>records</em> you will also have to supply the names of the data columns
in the keyword argument <em>columns</em>.</p>
<p>If you are reading from a file then it might be simpler to
use <a class="reference internal" href="programmers.html#recsql.sqlarray.SQLarray_fromfile" title="recsql.sqlarray.SQLarray_fromfile"><tt class="xref py py-func docutils literal"><span class="pre">recsql.sqlarray.SQLarray_fromfile()</span></tt></a>.</p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt>
<tt class="descname">SELECT</tt><big>(</big><em>fields</em>, <em>*args</em>, <em>**kwargs</em><big>)</big></dt>
<dd><p>Execute a simple SQL <tt class="docutils literal"><span class="pre">SELECT</span></tt> statement and returns values as new numpy rec array.</p>
<p>The arguments <em>fields</em> and the additional optional arguments
are simply concatenated with additional SQL statements
according to the template:</p>
<div class="highlight-python"><pre>SELECT &lt;fields&gt; FROM __self__ [args]</pre>
</div>
<p>The simplest fields argument is <tt class="docutils literal"><span class="pre">&quot;*&quot;</span></tt>.</p>
<dl class="docutils">
<dt>Example:</dt>
<dd><p class="first">Create a recarray in which students with average grade less than
3 are listed:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">result</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">SELECT</span><span class="p">(</span><span class="s">&quot;surname, subject, year, avg(grade) AS avg_grade&quot;</span><span class="p">,</span>
               <span class="s">&quot;WHERE avg_grade &lt; 3&quot;</span><span class="p">,</span> <span class="s">&quot;GROUP BY surname,subject&quot;</span><span class="p">,</span>
               <span class="s">&quot;ORDER BY avg_grade,surname&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>The resulting SQL would be:</p>
<div class="highlight-python"><pre>SELECT surname, subject, year, avg(grade) AS avg_grade FROM __self__
     WHERE avg_grade &lt; 3
     GROUP BY surname,subject
     ORDER BY avg_grade,surname</pre>
</div>
<p>Note how one can use aggregate functions such avg().</p>
<p>The string <em>&#8216;__self__&#8217;</em> is automatically replaced with the table
name (<tt class="docutils literal"><span class="pre">T.name</span></tt>); this can be used for cartesian products such as</p>
<div class="last highlight-python"><pre>LEFT JOIN __self__ WHERE ...</pre>
</div>
</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">See the documentation for <a class="reference internal" href="#recsql.SQLarray.sql" title="recsql.SQLarray.sql"><tt class="xref py py-meth docutils literal"><span class="pre">sql()</span></tt></a> for more details on
the available keyword arguments and the use of <tt class="docutils literal"><span class="pre">?</span></tt> parameter
interpolation.</p>
</div>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">limits</tt><big>(</big><em>variable</em><big>)</big></dt>
<dd><p>Return minimum and maximum of variable across all rows of data.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">merge</tt><big>(</big><em>recarray</em>, <em>columns=None</em><big>)</big></dt>
<dd><p>Merge another recarray with the same columns into this table.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Arguments :</th><td class="field-body"><dl class="first docutils">
<dt>recarray    </dt>
<dd><p class="first last">numpy record array that describes the layout and initializes the
table</p>
</dd>
</dl>
</td>
</tr>
<tr class="field"><th class="field-name">Returns :</th><td class="field-body"><p class="first">n           number of inserted rows</p>
</td>
</tr>
<tr class="field"><th class="field-name">Raises :</th><td class="field-body"><p class="first last">Raises an exception if duplicate and incompatible data exist
in the main table and the new one.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">merge_table</tt><big>(</big><em>name</em><big>)</big></dt>
<dd><p>Merge an existing table in the database with the __self__ table.</p>
<p>Executes as <tt class="docutils literal"><span class="pre">'INSERT</span> <span class="pre">INTO</span> <span class="pre">__self__</span> <span class="pre">SELECT</span> <span class="pre">*</span> <span class="pre">FROM</span> <span class="pre">&lt;name&gt;'</span></tt>.
However, this method is probably used less often than the simpler <a class="reference internal" href="#recsql.SQLarray.merge" title="recsql.SQLarray.merge"><tt class="xref py py-meth docutils literal"><span class="pre">merge()</span></tt></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Arguments :</th><td class="field-body">name         name of the table in the database (must be compatible with __self__)</td>
</tr>
<tr class="field"><th class="field-name">Returns :</th><td class="field-body">n            number of inserted rows</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt>
<tt class="descname">recarray</tt></dt>
<dd><p>Return underlying SQL table as a read-only record array.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">selection</tt><big>(</big><em>SQL</em>, <em>parameters=None</em>, <em>**kwargs</em><big>)</big></dt>
<dd><p>Return a new SQLarray from a SELECT selection.</p>
<p>This is a very useful method because it allows one to build complicated
selections and essentially new tables from existing data.</p>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">s</span> <span class="o">=</span> <span class="n">selection</span><span class="p">(</span><span class="s">&#39;a &gt; 3&#39;</span><span class="p">)</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">selection</span><span class="p">(</span><span class="s">&#39;a &gt; ?&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,))</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">selection</span><span class="p">(</span><span class="s">&#39;SELECT * FROM __self__ WHERE a &gt; ? AND b &lt; ?&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">sql</tt><big>(</big><em>SQL</em>, <em>parameters=None</em>, <em>asrecarray=True</em>, <em>cache=True</em><big>)</big></dt>
<dd><p>Execute sql statement.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Arguments :</th><td class="field-body"><dl class="first last docutils">
<dt>SQL <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">Full SQL command; can contain the <tt class="docutils literal"><span class="pre">?</span></tt> place holder so that values
supplied with the <tt class="docutils literal"><span class="pre">parameters</span></tt> keyword can be interpolated using
the <tt class="docutils literal"><span class="pre">pysqlite</span></tt> interface.</p>
</dd>
<dt>parameters <span class="classifier-delimiter">:</span> <span class="classifier">tuple</span></dt>
<dd><p class="first last">Parameters for <tt class="docutils literal"><span class="pre">?</span></tt> interpolation.</p>
</dd>
<dt>asrecarray <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><p class="first last"><tt class="xref docutils literal"><span class="pre">True</span></tt>: return a <tt class="docutils literal"><span class="pre">numpy.recarray</span></tt> if possible;
<tt class="xref docutils literal"><span class="pre">False</span></tt>: return records as a list of tuples. [<tt class="xref docutils literal"><span class="pre">True</span></tt>]</p>
</dd>
<dt>cache <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><p class="first last">Should the results be cached? Set to <tt class="xref docutils literal"><span class="pre">False</span></tt> for large queries to
avoid memory issues. Queries with <tt class="docutils literal"><span class="pre">?</span></tt> place holders are never cached.
[<tt class="xref docutils literal"><span class="pre">True</span></tt>]</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">There are <strong>no sanity checks</strong> applied to the SQL.</p>
</div>
<p>If  possible, the  returned list  of tuples  is turned  into a
numpy record  array, otherwise the original list  of tuples is
returned.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Potential BUG: if there are memory issues then it can
happen that we just silently fall back to a tuple even
though calling code expects a recarray; because we
swallowed ANY exception the caller will never know</p>
</div>
<p>The last cachesize queries are cached (for cache=True) and are
returned directly unless the table has been modified.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">&#8216;__self__&#8217; is substituted with the table name. See the doc
string of the <a class="reference internal" href="#recsql.SQLarray.SELECT" title="recsql.SQLarray.SELECT"><tt class="xref py py-meth docutils literal"><span class="pre">SELECT()</span></tt></a> method for more details.</p>
</div>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">sql_index</tt><big>(</big><em>index_name</em>, <em>column_names</em>, <em>unique=True</em><big>)</big></dt>
<dd><p>Add a named index on given columns to improve performance.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">sql_select</tt><big>(</big><em>fields</em>, <em>*args</em>, <em>**kwargs</em><big>)</big></dt>
<dd><p>Execute a simple SQL <tt class="docutils literal"><span class="pre">SELECT</span></tt> statement and returns values as new numpy rec array.</p>
<p>The arguments <em>fields</em> and the additional optional arguments
are simply concatenated with additional SQL statements
according to the template:</p>
<div class="highlight-python"><pre>SELECT &lt;fields&gt; FROM __self__ [args]</pre>
</div>
<p>The simplest fields argument is <tt class="docutils literal"><span class="pre">&quot;*&quot;</span></tt>.</p>
<dl class="docutils">
<dt>Example:</dt>
<dd><p class="first">Create a recarray in which students with average grade less than
3 are listed:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">result</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">SELECT</span><span class="p">(</span><span class="s">&quot;surname, subject, year, avg(grade) AS avg_grade&quot;</span><span class="p">,</span>
               <span class="s">&quot;WHERE avg_grade &lt; 3&quot;</span><span class="p">,</span> <span class="s">&quot;GROUP BY surname,subject&quot;</span><span class="p">,</span>
               <span class="s">&quot;ORDER BY avg_grade,surname&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>The resulting SQL would be:</p>
<div class="highlight-python"><pre>SELECT surname, subject, year, avg(grade) AS avg_grade FROM __self__
     WHERE avg_grade &lt; 3
     GROUP BY surname,subject
     ORDER BY avg_grade,surname</pre>
</div>
<p>Note how one can use aggregate functions such avg().</p>
<p>The string <em>&#8216;__self__&#8217;</em> is automatically replaced with the table
name (<tt class="docutils literal"><span class="pre">T.name</span></tt>); this can be used for cartesian products such as</p>
<div class="last highlight-python"><pre>LEFT JOIN __self__ WHERE ...</pre>
</div>
</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">See the documentation for <a class="reference internal" href="#recsql.SQLarray.sql" title="recsql.SQLarray.sql"><tt class="xref py py-meth docutils literal"><span class="pre">sql()</span></tt></a> for more details on
the available keyword arguments and the use of <tt class="docutils literal"><span class="pre">?</span></tt> parameter
interpolation.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="function">
<dt>
<tt class="descclassname">recsql.</tt><tt class="descname">SQLarray_fromfile</tt><big>(</big><em>filename</em>, <em>**kwargs</em><big>)</big></dt>
<dd><p>Create a <a class="reference internal" href="#recsql.SQLarray" title="recsql.SQLarray"><tt class="xref py py-class docutils literal"><span class="pre">SQLarray</span></tt></a> from <em>filename</em>.</p>
<dl class="docutils">
<dt>Uses the filename suffix to detect the contents:</dt>
<dd><dl class="first last docutils">
<dt>rst, txt</dt>
<dd>restructure text (see <a class="reference internal" href="programmers.html#module-recsql.rest_table" title="recsql.rest_table"><tt class="xref py py-mod docutils literal"><span class="pre">recsql.rest_table</span></tt></a></dd>
<dt>csv</dt>
<dd>comma-separated (see <a class="reference internal" href="programmers.html#module-recsql.csv_table" title="recsql.csv_table"><tt class="xref py py-mod docutils literal"><span class="pre">recsql.csv_table</span></tt></a>)</dd>
</dl>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Arguments :</th><td class="field-body"><dl class="first last docutils">
<dt><em>filename</em></dt>
<dd><p class="first last">name of the file that contains the data with the appropriate
file extension</p>
</dd>
<dt><em>kwargs</em></dt>
<dd><ul class="first last simple">
<li>additional arguments for <a class="reference internal" href="#recsql.SQLarray" title="recsql.SQLarray"><tt class="xref py py-class docutils literal"><span class="pre">SQLarray</span></tt></a></li>
<li>additional arguments <a class="reference internal" href="programmers.html#recsql.csv_table.Table2array" title="recsql.csv_table.Table2array"><tt class="xref py py-class docutils literal"><span class="pre">recsql.csv_table.Table2array</span></tt></a> or
<a class="reference internal" href="programmers.html#recsql.rest_table.Table2array" title="recsql.rest_table.Table2array"><tt class="xref py py-class docutils literal"><span class="pre">recsql.rest_table.Table2array</span></tt></a> such as <em>mode</em> or
<em>autoncovert</em>.</li>
</ul>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">User documentation</a><ul>
<li><a class="reference internal" href="#recsql-package">RecSQL package</a><ul>
<li><a class="reference internal" href="#important-functions-and-classes">Important functions and classes</a></li>
<li><a class="reference internal" href="#example">Example</a></li>
<li><a class="reference internal" href="#additional-sql-functions">Additional SQL functions</a><ul>
<li><a class="reference internal" href="#simple-sql-functions">Simple SQL functions</a></li>
<li><a class="reference internal" href="#aggregate-sql-functions">Aggregate SQL functions</a></li>
<li><a class="reference internal" href="#pyaggregate-sql-functions">PyAggregate SQL functions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#examples-of-using-types-in-tables">Examples of using types in tables</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="INSTALL.html"
                        title="previous chapter">INSTALL</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="programmers.html"
                        title="next chapter">Notes for developers</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/users.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="programmers.html" title="Notes for developers"
             >next</a> |</li>
        <li class="right" >
          <a href="INSTALL.html" title="INSTALL"
             >previous</a> |</li>
        <li><a href="index.html">RecSQL v0.7.4 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2007-2010, Oliver Beckstein.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.4.
    </div>
  </body>
</html>